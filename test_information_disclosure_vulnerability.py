#!/usr/bin/env python3
"""
Test for Information Disclosure Vulnerability (ID-001)

This test demonstrates the current information disclosure vulnerability where
exception logging with exc_info=True exposes sensitive system information
including stack traces, file paths, and internal system architecture.

Location: src/reasoning_library/null_handling.py:224
Vulnerability: logger.debug(..., exc_info=True)
"""

import logging
import sys
import io
from contextlib import redirect_stderr
from typing import Any

# Import the vulnerable function
from src.reasoning_library.null_handling import with_null_safety


class LogCapture:
    """Capture log output for testing."""

    def __init__(self):
        self.logs = []
        self.handler = None
        self.logger = None
        self.stdout_capture = None

    def start_capture(self):
        """Start capturing logs from stdout/stderr."""
        self.logs = []

        # Capture stderr where debug logs are typically written
        self.stdout_capture = io.StringIO()

        # Create a custom handler that captures log records
        class TestHandler(logging.Handler):
            def __init__(self, log_list):
                super().__init__()
                self.log_list = log_list

            def emit(self, record):
                # Capture the full log message including exception info if present
                if record.exc_info:
                    # Format the exception to see what sensitive data is exposed
                    formatted = self.format(record)
                    self.log_list.append(formatted)
                else:
                    self.log_list.append(record.getMessage())

        self.handler = TestHandler(self.logs)
        self.handler.setLevel(logging.DEBUG)

        # Set up root logger to capture all debug output
        self.logger = logging.getLogger()
        self.logger.addHandler(self.handler)
        self.logger.setLevel(logging.DEBUG)

    def stop_capture(self):
        """Stop capturing logs."""
        if self.handler and self.logger:
            self.logger.removeHandler(self.handler)

    def get_logs(self):
        """Return captured logs."""
        return self.logs


def test_information_disclosure_vulnerability():
    """
    Test that demonstrates the current information disclosure vulnerability.

    This test shows that when business exceptions are caught and logged with
    exc_info=True, sensitive system information is exposed including:
    - Full file paths
    - Stack traces showing system architecture
    - Internal function call sequences
    - Python environment details
    """
    print("=== INFORMATION DISCLOSURE VULNERABILITY DEMONSTRATION ===")

    # Capture stderr output to demonstrate vulnerability
    stderr_capture = io.StringIO()

    with redirect_stderr(stderr_capture):
        # Create a function that will trigger a business exception
        @with_null_safety(expected_return_type=str)
        def vulnerable_function():
            # This will trigger a KeyError which is caught and logged with exc_info=True
            data = {"key": "value"}
            return data["missing_key"]  # KeyError (business logic error)

        # Configure logging to show debug output with exception info
        logging.basicConfig(level=logging.DEBUG, format='%(levelname)s:%(name)s:%(message)s')

        # Call the function to trigger the vulnerable logging
        result = vulnerable_function()

    # Get the captured stderr output
    stderr_output = stderr_capture.getvalue()

    print(f"Function result: {result}")
    print(f"Captured log output length: {len(stderr_output)} characters")

    # Display the captured vulnerability
    print(f"\n--- VULNERABLE LOG OUTPUT ---")
    print(stderr_output)

    # Analyze what sensitive information is being disclosed
    sensitive_info_found = []

    # Check for types of sensitive information being disclosed
    if "Traceback (most recent call last):" in stderr_output:
        sensitive_info_found.append("Full stack trace")

    if "src/reasoning_library" in stderr_output:
        sensitive_info_found.append("System file paths")

    if "Users/eringreen/Development" in stderr_output:
        sensitive_info_found.append("User directory paths")

    if "vulnerable_function" in stderr_output:
        sensitive_info_found.append("Internal function names")

    if "null_handling.py" in stderr_output:
        sensitive_info_found.append("Source file names")

    print(f"\n=== SENSITIVE INFORMATION DISCLOSED ===")
    for info_type in sensitive_info_found:
        print(f"‚ùå {info_type}")

    # Verify vulnerability exists
    assert len(stderr_output) > 0, "No log output captured - vulnerability test setup failed"

    # Check that sensitive information is being disclosed
    contains_traceback = "Traceback" in stderr_output
    contains_file_paths = "src/reasoning_library" in stderr_output
    contains_user_paths = "Users/eringreen" in stderr_output

    print(f"\n=== VULNERABILITY CONFIRMATION ===")
    print(f"Stack traces exposed: {contains_traceback}")
    print(f"File paths exposed: {contains_file_paths}")
    print(f"User directory paths exposed: {contains_user_paths}")

    if contains_traceback or contains_file_paths or contains_user_paths:
        print("üö® INFORMATION DISCLOSURE VULNERABILITY CONFIRMED!")
        print("   Exception logging with exc_info=True exposes sensitive system data")
        return True
    else:
        print("‚úÖ No information disclosure detected")
        return False


def test_secure_logging_requirements():
    """
    Define what secure logging should look like after the fix.

    Secure logging should:
    - NOT include full stack traces (no exc_info=True)
    - NOT include system file paths
    - NOT expose internal function call sequences
    - Include only relevant exception type and sanitized message
    """
    print("\n=== SECURE LOGGING REQUIREMENTS ===")
    print("After fix, logging should contain:")
    print("‚úÖ Exception type (e.g., 'KeyError')")
    print("‚úÖ Sanitized exception message")
    print("‚úÖ Function name for context")
    print("‚ùå Full stack trace")
    print("‚ùå File system paths")
    print("‚ùå Internal call sequences")
    print("‚ùå Environment details")


def demonstrate_attack_scenario():
    """
    Demonstrate how this vulnerability could be exploited.

    An attacker could:
    1. Trigger various types of business exceptions
    2. Analyze the resulting logs to understand system architecture
    3. Identify file paths, function names, and system structure
    4. Use this information for targeted attacks
    """
    print("\n=== ATTACK SCENARIO DEMONSTRATION ===")

    # Simulate an attacker probing for system information
    attack_vectors = [
        ("IndexError", lambda: "test"[100]),
        ("KeyError", lambda: {}["missing_key"]),
        ("TypeError", lambda: "string" + 123),
        ("ValueError", lambda: int("not_a_number")),
    ]

    log_capture = LogCapture()

    for attack_name, attack_func in attack_vectors:
        print(f"\nAttacker testing: {attack_name}")

        @with_null_safety(expected_return_type=str)
        def target_function():
            return attack_func()

        log_capture.start_capture()
        result = target_function()  # This triggers vulnerable logging
        log_capture.stop_capture()
        logs = log_capture.get_logs()

        # Show what information attacker can gather
        for log in logs:
            if log.strip():
                print(f"  Revealed: {log[:100]}...")

    print("\nAn attacker could use this information to:")
    print("- Map system architecture")
    print("- Identify potential targets for further attacks")
    print("- Understand codebase structure")
    print("- Plan targeted exploitation")


if __name__ == "__main__":
    print("üîç INFORMATION DISCLOSURE VULNERABILITY TEST (ID-001)")
    print("=" * 60)

    # Run vulnerability demonstration
    vulnerability_exists = test_information_disclosure_vulnerability()

    # Show secure requirements
    test_secure_logging_requirements()

    # Demonstrate attack impact
    demonstrate_attack_scenario()

    print("\n" + "=" * 60)
    if vulnerability_exists:
        print("RESULT: üö® VULNERABILITY REQUIRES IMMEDIATE FIX")
        print("ACTION: Implement secure exception handling without exc_info=True")
        sys.exit(1)
    else:
        print("RESULT: ‚úÖ NO VULNERABILITY DETECTED")
        sys.exit(0)