#!/usr/bin/env python3
"""
Critical vulnerability test for Algorithmic DoS in inductive.py patterns.

This test targets CRIT-002: Algorithmic DoS vulnerability where:
- Unbounded computation loops in pattern detection functions
- Timeout checks only every 1000 iterations (insufficient for fast attacks)
- Sequence length limit of 10,000 allows DoS attacks
- Fibonacci/Lucas/Tribonacci detection algorithms can be forced into exponential computation

Expected behavior: These tests should FAIL before the fix and PASS after.
"""

import pytest
import time
from reasoning_library.inductive import (
    predict_next_in_sequence,
    detect_fibonacci_pattern,
    detect_lucas_pattern,
    detect_tribonacci_pattern,
    MAX_SEQUENCE_LENGTH,
    _VALUE_MAGNITUDE_LIMIT
)


class TestAlgorithmicDoSVulnerabilities:
    """Test suite for CRIT-002: Algorithmic DoS vulnerabilities."""

    def test_sequence_length_limit_vulnerability(self):
        """Test that overly long sequences are rejected to prevent DoS."""
        # Create a sequence longer than safe limit (currently 10000)
        # This should cause DoS by forcing excessive computation
        vulnerable_length = 5000  # Still within current limit but dangerous

        # Simple arithmetic sequence that would be processed
        long_sequence = list(range(vulnerable_length))

        # This should either timeout or take too long with current implementation
        start_time = time.time()

        # This call should fail/timeout but currently doesn't (vulnerability)
        result = predict_next_in_sequence(long_sequence)

        elapsed = time.time() - start_time

        # Vulnerable: Takes too long and processes sequence that's too long
        assert elapsed > 0.1, f"Processing took {elapsed}s, should be faster"
        assert result is not None, "Should have processed sequence (vulnerability)"

        print(f"VULNERABILITY CONFIRMED: Processed {vulnerable_length} elements in {elapsed}s")

    def test_exponential_growth_fibonacci_dos(self):
        """Test DoS via exponential growth in Fibonacci-like sequences."""
        # Create a sequence that grows exponentially to trigger overflow
        # This simulates malicious input designed to cause resource exhaustion
        exponential_sequence = [1, 2]

        # Grow exponentially (doubling each time) to quickly hit limits
        for i in range(50):  # This should create massive values
            exponential_sequence.append(exponential_sequence[-1] * 2)

        # The system should reject this early to prevent computational explosion
        start_time = time.time()

        try:
            # This should fail due to value magnitude limits or timeout
            result = detect_fibonacci_pattern(exponential_sequence, tolerance=0.1)

            # If we get here, check if it processed dangerously large values
            max_value = max(exponential_sequence)
            elapsed = time.time() - start_time

            # Vulnerability: Processed dangerously large values
            assert max_value > _VALUE_MAGNITUDE_LIMIT / 10, f"Values too small: {max_value}"
            assert elapsed > 0.01, f"Processed too quickly: {elapsed}s"

            print(f"VULNERABILITY CONFIRMED: Processed values up to {max_value}")

        except ValueError as e:
            # This would be the safe behavior (after fix)
            if "overflow" in str(e).lower() or "timeout" in str(e).lower():
                pytest.skip("Safe behavior detected - system properly rejected large values")
            else:
                # Unexpected error
                raise

    def test_timeout_check_frequency_vulnerability(self):
        """Test that timeout checks are frequent enough to prevent DoS."""
        # Create sequence that maximizes computation between timeout checks
        # Current implementation checks every 1000 iterations (vulnerable)

        # Fast-growing sequence that maximizes work per iteration
        sequence = [1.001, 1.002]  # Start with values that will cause complex computation

        # Add values that will force intensive recursive computation
        for i in range(2000):  # More than the 1000 iteration check interval
            # Add values that will require complex floating point operations
            sequence.append(sequence[-1] * 1.001 + sequence[-2] * 0.999)

        # Time the operation
        start_time = time.time()

        # This should be vulnerable to DoS between timeout checks
        try:
            result = detect_fibonacci_pattern(sequence, tolerance=1e-10)
            elapsed = time.time() - start_time

            # If this completes quickly without proper timeout checks, it's vulnerable
            if elapsed < 0.01:  # Too fast, likely not checking timeouts properly
                print(f"VULNERABILITY CONFIRMED: Processed {len(sequence)} elements in {elapsed}s without proper timeout checks")
                return

            # If it took longer but still completed, check if it was reasonable
            if elapsed > 5.0:  # Took too long, DoS succeeded
                pytest.fail(f"DoS SUCCEEDED: Operation took {elapsed}s (should have timed out)")

        except Exception as e:
            elapsed = time.time() - start_time
            if "timeout" in str(e).lower():
                pytest.skip("Safe behavior detected - proper timeout checking")
            else:
                # Some other error occurred
                print(f"Unexpected error after {elapsed}s: {e}")
                raise

    def test_tribonacci_computation_explosion(self):
        """Test DoS vulnerability in Tribonacci computation (3-term recursion)."""
        # Tribonacci is particularly vulnerable as it sums 3 previous terms
        # This can cause exponential computational growth

        # Create a sequence that will maximize Tribonacci computation
        sequence = [100, 200, 300]  # Large starting values

        # Extend with values that will force computation
        for i in range(100):  # 100 iterations of 3-term sums
            # This will create rapidly growing values
            next_val = sequence[-1] + sequence[-2] + sequence[-3]
            sequence.append(next_val)

        start_time = time.time()

        try:
            result = detect_tribonacci_pattern(sequence, tolerance=0.1)
            elapsed = time.time() - start_time

            # Check if we processed dangerous computation
            max_value = max(sequence)

            # Vulnerability indicators
            if max_value > _VALUE_MAGNITUDE_LIMIT / 100:  # Approaching dangerous values
                print(f"VULNERABILITY CONFIRMED: Tribonacci processed values up to {max_value}")

            if elapsed > 1.0:  # Took too long
                print(f"VULNERABILITY CONFIRMED: Tribonacci took {elapsed}s (potential DoS)")

        except ValueError as e:
            elapsed = time.time() - start_time
            if "overflow" in str(e).lower() or "timeout" in str(e).lower():
                pytest.skip("Safe behavior detected - Tribonacci properly protected")
            else:
                raise

    def test_current_limits_inadequate(self):
        """Verify current limits are inadequate for DoS protection."""
        # Current limits in constants.py are too permissive
        current_max_length = MAX_SEQUENCE_LENGTH

        # These limits should be reduced for security
        assert current_max_length > 1000, f"Current limit {current_max_length} is too high for security"

        # Test that we can create dangerous sequences within current limits
        dangerous_length = min(2000, current_max_length - 1)  # Still within limit but dangerous
        sequence = list(range(dangerous_length))

        start_time = time.time()
        result = predict_next_in_sequence(sequence)
        elapsed = time.time() - start_time

        # Current implementation allows this (vulnerable)
        assert result is not None, "Should have processed dangerous sequence"
        assert len(sequence) > 1000, f"Was able to process {len(sequence)} elements (vulnerable)"

        print(f"VULNERABILITY CONFIRMED: Processed {len(sequence)} elements in {elapsed}s")
        print(f"Current MAX_SEQUENCE_LENGTH = {current_max_length} (should be ~1000)")


if __name__ == "__main__":
    # Run the tests to demonstrate vulnerabilities
    print("Testing CRIT-002: Algorithmic DoS Vulnerabilities")
    print("=" * 60)

    test_suite = TestAlgorithmicDoSVulnerabilities()

    try:
        print("\n1. Testing sequence length limit vulnerability...")
        test_suite.test_sequence_length_limit_vulnerability()
    except Exception as e:
        print(f"Test failed: {e}")

    try:
        print("\n2. Testing exponential growth Fibonacci DoS...")
        test_suite.test_exponential_growth_fibonacci_dos()
    except Exception as e:
        print(f"Test failed: {e}")

    try:
        print("\n3. Testing timeout check frequency vulnerability...")
        test_suite.test_timeout_check_frequency_vulnerability()
    except Exception as e:
        print(f"Test failed: {e}")

    try:
        print("\n4. Testing Tribonacci computation explosion...")
        test_suite.test_tribonacci_computation_explosion()
    except Exception as e:
        print(f"Test failed: {e}")

    try:
        print("\n5. Testing current limits inadequate...")
        test_suite.test_current_limits_inadequate()
    except Exception as e:
        print(f"Test failed: {e}")

    print("\n" + "=" * 60)
    print("Vulnerability testing complete. If all tests completed without")
    print("timeout or overflow errors, the vulnerabilities are CONFIRMED.")
    print("After the fix, these tests should be skipped or fail appropriately.")