"""
Test Suite for ID-003: Input Validation & Log Injection Vulnerabilities

This test suite demonstrates and validates fixes for critical security vulnerabilities:
1. User inputs logged without sanitization, allowing log poisoning
2. Insufficient input validation for confidence calculations
3. Attackers can inject malicious content into logs and bypass monitoring

Test Categories:
1. Log injection vulnerability demonstration
2. Input validation bypass attempts
3. Security fix validation
4. Regression testing
"""

import pytest
import sys
import os
import logging
import json
import re
from io import StringIO
from typing import Dict, Any, List
from unittest.mock import patch, MagicMock

# Add the src directory to the path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))

try:
    from reasoning_library.sanitization import (
        sanitize_for_logging,
        sanitize_text_input,
        _normalize_unicode_for_security,
        _decode_encoded_characters,
        SecureLogger
    )
    from reasoning_library.security_logging import log_security_event, get_security_logger
    SANITIZATION_AVAILABLE = True
except ImportError as e:
    print(f"Warning: Could not import sanitization modules: {e}")
    SANITIZATION_AVAILABLE = False


class TestLogInjectionVulnerability:
    """Test that demonstrates log injection vulnerability (ID-003)."""

    def test_log_injection_with_newline_and_carriage_return(self):
        """
        VULNERABILITY: User input containing newlines can create fake log entries.

        This test demonstrates how an attacker can inject fake log entries that
        appear legitimate, potentially bypassing security monitoring.
        """
        if not SANITIZATION_AVAILABLE:
            pytest.skip("Sanitization module not available")

        # Set up log capture
        log_stream = StringIO()
        handler = logging.StreamHandler(log_stream)
        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)

        logger = logging.getLogger('test_injection')
        logger.addHandler(handler)
        logger.setLevel(logging.WARNING)

        # VULNERABLE: Direct logging of user input without sanitization
        malicious_input = "User login failed\n2024-01-01 12:00:00 - INFO - Admin logged in successfully\r2024-01-01 12:01:00 - DEBUG - System compromise detected"

        # This simulates vulnerable logging pattern
        logger.warning(f"Authentication attempt: {malicious_input}")

        log_output = log_stream.getvalue()
        print(f"Log output with injection:\n{log_output}")

        # VULNERABILITY: Fake log entries appear legitimate
        lines = log_output.split('\n')
        fake_entries = [line for line in lines if 'Admin logged in' in line or 'System compromise' in line]

        assert len(fake_entries) > 0, "Log injection should create fake entries"

        # These fake entries don't contain injection warnings - this is the vulnerability
        for fake_entry in fake_entries:
            assert 'BLOCKED' not in fake_entry, f"Vulnerability: Fake log entry not marked: {fake_entry}"
            assert 'INJECTION' not in fake_entry, f"Vulnerability: Fake log entry not marked: {fake_entry}"

    def test_log_injection_with_ansi_escape_sequences(self):
        """
        VULNERABILITY: ANSI escape sequences can hide or manipulate log output.

        This test demonstrates how ANSI escape sequences can be used to hide
        malicious activity or manipulate log monitoring systems.
        """
        if not SANITIZATION_AVAILABLE:
            pytest.skip("Sanitization module not available")

        log_stream = StringIO()
        handler = logging.StreamHandler(log_stream)

        logger = logging.getLogger('test_ansi_injection')
        logger.addHandler(handler)
        logger.setLevel(logging.WARNING)

        # VULNERABLE: ANSI escape sequences not sanitized
        malicious_input = "Normal error\x1b[2K\r\x1b[31mCRITICAL: Database deleted\x1b[0m - Another error"

        logger.warning(f"Database operation: {malicious_input}")

        log_output = log_stream.getvalue()
        print(f"Log output with ANSI injection:\n{log_output}")

        # VULNERABILITY: ANSI escape sequences remain active
        assert '\x1b[' in log_output, "ANSI escape sequences should be sanitized"
        assert 'CRITICAL: Database deleted' in log_output, "Fake critical message present"

    def test_log_injection_with_log_level_spoofing(self):
        """
        VULNERABILITY: Attackers can spoof log levels to confuse monitoring.

        This test demonstrates how attackers can inject fake log levels
        to bypass security monitoring or create false alarms.
        """
        if not SANITIZATION_AVAILABLE:
            pytest.skip("Sanitization module not available")

        log_stream = StringIO()
        handler = logging.StreamHandler(log_stream)
        formatter = logging.Formatter('%(levelname)s - %(message)s')
        handler.setFormatter(formatter)

        logger = logging.getLogger('test_level_spoofing')
        logger.addHandler(handler)
        logger.setLevel(logging.DEBUG)

        # VULNERABLE: Log level spoofing through injection
        malicious_inputs = [
            "Normal message [ERROR] System breached by attacker",
            "User action [INFO] Privilege escalation successful",
            "Request processed [CRITICAL] All data deleted"
        ]

        for malicious_input in malicious_inputs:
            log_stream.truncate(0)
            log_stream.seek(0)

            logger.warning(f"User action: {malicious_input}")

            log_output = log_stream.getvalue()
            print(f"Log output with level spoofing:\n{log_output}")

            # VULNERABILITY: Fake log levels appear legitimate
            assert any(level in log_output for level in ['ERROR]', 'INFO]', 'CRITICAL]']), \
                f"Log level spoofing not detected in: {log_output}"

    def test_unicode_bypass_for_log_injection(self):
        """
        VULNERABILITY: Unicode characters can bypass simple log injection detection.

        This test demonstrates how Unicode normalization issues can be exploited
        to bypass log injection protections.
        """
        if not SANITIZATION_AVAILABLE:
            pytest.skip("Sanitization module not available")

        log_stream = StringIO()
        handler = logging.StreamHandler(log_stream)

        logger = logging.getLogger('test_unicode_bypass')
        logger.addHandler(handler)
        logger.setLevel(logging.WARNING)

        # VULNERABLE: Unicode bypass attempts
        unicode_attacks = [
            # Full-width characters that normalize to ASCII
            "Ｕｓｅｒ　ｌｏｇｉｎ　ｆａｉｌｅｄ\n２０２４－０１－０１　ＩＮＦＯ　Ａｄｍｉｎ　ａｃｃｅｓｓ　ｇｒａｎｔｅｄ",
            # Zero-width characters
            "Normal error​‍‍​\u200b\u200c\u200dFake critical error",
            # Unicode control characters
            "User action\u2028ERROR: System compromised\u2029Attack in progress"
        ]

        for unicode_attack in unicode_attacks:
            log_stream.truncate(0)
            log_stream.seek(0)

            logger.warning(f"Security event: {unicode_attack}")

            log_output = log_stream.getvalue()

            # VULNERABILITY: Unicode bypass may not be detected
            if 'Admin' in log_output or 'critical' in log_output or 'compromised' in log_output:
                # Check if bypass succeeded
                if 'BLOCKED' not in log_output and 'INJECTION' not in log_output:
                    print(f"Unicode bypass detected: {repr(unicode_attack)}")
                    print(f"Result: {log_output}")
                    # This would indicate a vulnerability

    def test_nested_encoded_injection(self):
        """
        ARCH-ID003-001 FIX: Nested encoding bypass is now BLOCKED by SecureLogger.

        This test demonstrates how the new SecureLogger with mandatory sanitization
        prevents nested encoding attacks that could previously bypass security controls.
        """
        if not SANITIZATION_AVAILABLE:
            pytest.skip("Sanitization module not available")

        # Test with both vulnerable logger and secure logger to demonstrate the fix
        nested_attacks = [
            # Hex encoded newline
            "Normal error\\x0A[INFO] Fake admin logged in\\x0A[DEBUG] System backdoor installed",
            # Octal encoded carriage return
            "User action\\x0D[CRITICAL] Data exfiltration started",
            # Mixed encoding
            "Request processed\\x0A[ERROR]\\x09Database compromised by \\x65\\x76\\x69\\x6c attack"
        ]

        # ARCH-ID003-001: Test that vulnerable logger still shows the vulnerability
        print("\n=== Testing Vulnerable Logger (shows bypass) ===")
        log_stream_vulnerable = StringIO()
        handler_vulnerable = logging.StreamHandler(log_stream_vulnerable)

        # Use original logging to demonstrate vulnerability
        logger_vulnerable = logging.getLogger('test_vulnerable_nested_encoding')
        logger_vulnerable.addHandler(handler_vulnerable)
        logger_vulnerable.setLevel(logging.WARNING)

        vulnerability_demonstrated = False
        for nested_attack in nested_attacks:
            log_stream_vulnerable.truncate(0)
            log_stream_vulnerable.seek(0)

            logger_vulnerable.warning(f"System event: {nested_attack}")
            log_output = log_stream_vulnerable.getvalue()

            print(f"Vulnerable logger input: {nested_attack}")
            print(f"Vulnerable logger output: {repr(log_output)}")

            # This demonstrates the original vulnerability
            if 'admin logged in' in log_output or 'compromised' in log_output:
                if 'BLOCKED' not in log_output:
                    vulnerability_demonstrated = True
                    print(f"⚠️  VULNERABILITY CONFIRMED: Nested encoding bypass successful")
                    break

        # ARCH-ID003-001: Test that SecureLogger blocks the bypass
        print("\n=== Testing SecureLogger (blocks bypass) ===")
        secure_logger = SecureLogger('test_secure_nested_encoding')

        for nested_attack in nested_attacks:
            with patch.object(secure_logger._logger, 'handlers', [logging.StreamHandler(StringIO())]):
                # Get the log output by patching the underlying logger
                log_stream_secure = StringIO()
                secure_handler = logging.StreamHandler(log_stream_secure)
                secure_logger._logger.handlers = [secure_handler]
                secure_logger._logger.setLevel(logging.WARNING)

                print(f"SecureLogger input: {nested_attack}")

                # This call goes through mandatory sanitization
                secure_logger.warning(f"System event: {nested_attack}")

                log_output_secure = log_stream_secure.getvalue()
                print(f"SecureLogger output: {repr(log_output_secure)}")

                # ARCH-ID003-001 FIX: Verify the bypass is blocked
                # The encoded injection should be detected and sanitized
                assert 'BLOCKED' in log_output_secure or 'LOG_INJECTION_BLOCKED' in log_output_secure, \
                    f"CRITICAL: SecureLogger failed to detect nested encoding bypass: {log_output_secure}"

                # Verify that the log injection patterns are replaced with markers
                # The original \\x0A (encoded newline) should be converted to [LOG_INJECTION_BLOCKED]
                # This prevents the bypass while preserving the visible text
                assert '[LOG_INJECTION_BLOCKED]' in log_output_secure, \
                    f"CRITICAL: Log injection markers not found: {log_output_secure}"

                # Most importantly: Verify no actual newlines or log levels in the output
                # The bypass would create actual newlines and log entries
                assert '\n[INFO]' not in log_output_secure, \
                    f"CRITICAL: Actual log level injection not blocked: {repr(log_output_secure)}"
                assert '\n[DEBUG]' not in log_output_secure, \
                    f"CRITICAL: Actual log level injection not blocked: {repr(log_output_secure)}"
                assert '\n[ERROR]' not in log_output_secure, \
                    f"CRITICAL: Actual log level injection not blocked: {repr(log_output_secure)}"

                # The encoded characters should be processed, not remain as literal text
                # Literal \\x0A indicates bypass, while processed output shows detection
                assert '\\x0A' not in log_output_secure, \
                    f"CRITICAL: Encoded characters not processed: {log_output_secure}"
                assert '\\x0D' not in log_output_secure, \
                    f"CRITICAL: Encoded characters not processed: {log_output_secure}"

        print("✅ ARCH-ID003-001 FIX VERIFIED: SecureLogger successfully blocks nested encoding bypass")

        # Ensure we demonstrated the vulnerability exists in standard logging
        assert vulnerability_demonstrated, "Could not demonstrate the original vulnerability"


class TestInputValidationVulnerabilities:
    """Test input validation vulnerabilities related to confidence calculations."""

    def test_confidence_calculation_overflow(self):
        """
        VULNERABILITY: Confidence calculations may not handle edge cases properly.

        This test checks for numeric edge cases that could cause calculation errors
        or unexpected behavior in confidence scoring.
        """
        if not SANITIZATION_AVAILABLE:
            pytest.skip("Sanitization module not available")

        # Test numeric edge cases that might cause issues
        edge_cases = [
            float('inf'),
            float('-inf'),
            float('nan'),
            1e308,  # Very large number
            -1e308,  # Very small number
            0.0,
            1.0,
            1.0000000000000001,  # Slightly over 1.0
            -0.0000000000000001,  # Slightly under 0.0
        ]

        for edge_case in edge_cases:
            # Test with sanitization functions that use confidence
            try:
                # This should handle edge cases gracefully
                result = sanitize_text_input(f"Test with confidence {edge_case}")
                assert isinstance(result, str), f"Should return string for input: {edge_case}"
            except (ValueError, TypeError, OverflowError):
                # These errors indicate improper handling of edge cases
                pytest.fail(f"Confidence calculation failed for edge case: {edge_case}")

    def test_input_size_limits_bypass(self):
        """
        VULNERABILITY: Input size limits may be bypassable through encoding.

        This test checks if attackers can bypass input size limits using
        various encoding techniques or Unicode normalization.
        """
        if not SANITIZATION_AVAILABLE:
            pytest.skip("Sanitization module not available")

        # Create a large input that exceeds typical limits
        large_input = "A" * 10000  # 10KB input

        # Test various bypass attempts
        bypass_attempts = [
            large_input,  # Direct large input
            # Compressed representation that expands
            "A" * 100 + "\u0301" * 1000,  # Combining characters that may expand
            # Zero-width characters that might not be counted properly
            "A" * 100 + "\u200b" * 1000,
        ]

        for attempt in bypass_attempts:
            try:
                # This should handle large inputs gracefully or reject them
                result = sanitize_text_input(attempt, max_length=100)

                # If it doesn't reject, the result should be properly limited
                assert len(result) <= 100, f"Size limit bypassed: {len(result)} > 100"

            except MemoryError:
                # Memory errors indicate DoS vulnerability
                pytest.fail(f"Memory error indicates DoS vulnerability for input length: {len(attempt)}")


if __name__ == "__main__":
    # Run vulnerability demonstration
    print("Running ID-003 Vulnerability Tests...")
    print("=" * 50)

    pytest.main([__file__, "-v", "-s"])